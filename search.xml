<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[深入浅出ConstraintLayout（约束布局）：Part1]]></title>
      <url>http://www.yangqinfeng.com/2016/09/02/2016-8-20-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAConstraintLayout%EF%BC%9Apart1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>ConstraintLayout和布局编辑器工具目前是预览版本。本文内容是基于 <code>constraint-layout:1.0.0-alpha4</code>的代码和行为。在最终版本的工具中这些行为可能会改变。</p>
</blockquote>
<p>谷歌I/O 2016年宣布了提高布局体验的新工具和库来构建Android应用程序，Android stuido已经嵌入了基于约束的可视化布局编辑器，和运行时解释这些约束的<code>ConstraintLayout</code>新容器。</p>
<p>本文重点解释<code>ConstraintLayout</code>容器的结构和它是如何工作的，新的Android stuido布局编辑器的功能是为开发者更容易管理<code>ConstraintLayout</code>容器强大和灵活的特性而设计的。深入理解<code>ConstraintLayout</code>,我们将能更好地使用开发工具。</p>
<blockquote>
<p><code>ConstraintLayout</code>作为一个非捆绑支持库发布，因此你会在本文看到许多XML属性以<code>app:</code>为前缀而非<code>android:</code>:因为它们都来自本地包命名空间。</p>
</blockquote>
<p>让我们从定义约束是什么开始…</p>
<a id="more"></a>
<h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><p>在上面google页面的链接中，一个放置在<code>view</code>的约束是 “ 描述<code>view</code>相对于布局中其他元素应该如何在屏幕上放置（a description of how that <code>view</code> should be positioned on the screen relative to other elements in the layout) ” ，换句话说，约束连接着<code>view</code>上的一个点（称为锚点）到某种目标，目标可以是：</p>
<ul>
<li>一个兄弟<code>view</code>上关系锚点</li>
<li>一个父容器上关系锚点</li>
<li>基准线(后面详细讨论)</li>
</ul>
<p>每个<code>view</code>支持以下锚点作为一个约束的源或目标:</p>
<ul>
<li>Top, Bottom, Left, and Right (or Start and End)</li>
<li>CenterX and CenterY</li>
<li>Baseline (text-based <code>view</code>s only)</li>
</ul>
<p>在XML中,约束采取以下形式:</p>
<p><code>layout_constraint[SourceAnchor]_[TargetAnchor]=&quot;[TargetId]&quot;</code></p>
<p>例如,在的@<code>id/button_cancel</code>结束和<code>@id/button_next</code>起始之间的约束看起来像:</p>
<pre><code>&lt;Button
  android:id=&quot;@+id/button_cancel&quot;
  …​ /&gt;

&lt;Button
  android:id=&quot;@+id/button_next&quot;
  app:layout_constraintStart_toEndOf=&quot;@+id/button_cancel&quot;
  …​ /&gt;
</code></pre><p>在可视化布局编辑器中,当你通过一个箭头连接两个<code>view</code>来表示约束,工具简单地添加XML到文件。这里有一个更完整一些ConstraintLayout XML的例子:</p>
<pre><code>&lt;android.support.constraint.ConstraintLayout
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
  xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  android:id=&quot;@+id/constraintLayout&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;

  &lt;Button
    android:id=&quot;@+id/button_cancel&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/constraintLayout&quot;
    android:layout_marginStart=&quot;16dp&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    android:layout_marginBottom=&quot;16dp&quot; /&gt;

  &lt;Button
    android:id=&quot;@+id/button_next&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toEndOf=&quot;@+id/button_cancel&quot;
    android:layout_marginStart=&quot;16dp&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    android:layout_marginBottom=&quot;16dp&quot;/&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p><img src="http://wiresareobsolete.com/wp-content/uploads/2016/07/SimpleButtons.png" alt="simpleButtons.png"></p>
<p>在这个例子中，我们有一些约束是相对父容器调整button <code>view</code>。正如我们之前看到的他们采用相同的格式,但目标是ConstraintLayout实例的id。</p>
<blockquote>
<p>约束总是通过android:id关联目标。如果添加约束的<code>view</code>没有id属性,为了创建约束，Android Studio布局编辑器将为您创建一个。</p>
</blockquote>
<p>您可能还注意到从最后一个例子,<code>ConstraintLayout</code>支持<code>margins</code>。默认情况下,两个<code>view</code>之间的约束将被解释为使<code>view</code>立即相邻。如果你想使它们之间有间距，<code>margins</code>是必需的。</p>
<p>听起来和<code>RelativeLayout</code>相当像，是不是？</p>
<h2 id="约束偏移"><a href="#约束偏移" class="headerlink" title="约束偏移"></a>约束偏移</h2><p>当一个<code>view</code>被相同轴的两侧同时约束，它将默认均分两个目标锚点间的距离。下面的XML是在父容器中心一个按钮:</p>
<pre><code>&lt;android.support.constraint.ConstraintLayout
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
  xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  android:id=&quot;@+id/constraintLayout&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;

  &lt;Button
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/button&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintEnd_toEndOf=&quot;@+id/constraintLayout&quot; /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p><img src="http://wiresareobsolete.com/wp-content/uploads/2016/07/CenteredButton.png" alt="CenteredButton.png"></p>
<p>这是一个不错的功能,但ConstraintLayout用偏移这个概念填上这个缺口。偏移施加<code>weight</code>因子于这对约束，达到非均分空间。例如:</p>
<pre><code>&lt;android.support.constraint.ConstraintLayout
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
  xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  android:id=&quot;@+id/constraintLayout&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;

  &lt;Button
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/button&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintEnd_toEndOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintHorizontal_bias=&quot;0.25&quot;
    app:layout_constraintVertical_bias=&quot;0.25&quot; /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p>现在相同的按钮是以25/75的<code>weight</code>分配每个轴上的可用空间。这是更接近于LinearLayout或GridLayout中的<code>weight</code>系统。但它比它们更好,因为<code>view</code>不必为了使用<code>weight</code>而去充满的可用空间。</p>
<blockquote>
<p>从技术上讲,当没有偏移约束存在, 偏移值是0.5。这就是为什么默认行为是中心的<code>view</code>。</p>
</blockquote>
<p>你希望可以开始看到ConstraintLayout拥有强大扁平视图层次结构。它可以像任何现有的框架布局管理器,或者他们所有!</p>
<h2 id="关联基准线"><a href="#关联基准线" class="headerlink" title="关联基准线"></a>关联基准线</h2><p>一般情况下,视图需要一个任意的锚点对齐,ConstraintLayout支持基准线。基准线实际上是<code>view</code>的一个子类,添加到布局就像任何其他的孩子。<code>view</code>有一些特殊的属性:</p>
<ol>
<li>它们的测量大小总为0</li>
<li>它们强制自己的可见性为<code>View.GONE</code></li>
</ol>
<p>因此,尽管它们作为<code>view</code>存在容器,他们在布局从不占空间。它们存在纯粹为了提供基准线属性而定义一个水平或垂直锚给其他<code>view</code>。让我们来看一个例子:</p>
<pre><code>&lt;android.support.constraint.ConstraintLayout
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
  xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  android:id=&quot;@+id/constraintLayout&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;

  &lt;android.support.constraint.Guideline
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/guideline&quot;
    android:orientation=&quot;vertical&quot;
    app:layout_constraintGuide_begin=&quot;72dp&quot; /&gt;

  &lt;Button
    android:id=&quot;@+id/button_cancel&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/guideline&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintVertical_bias=&quot;0.25&quot; /&gt;

  &lt;Button
    android:id=&quot;@+id/button_next&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/guideline&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintVertical_bias=&quot;0.75&quot; /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p><img src="http://wiresareobsolete.com/wp-content/uploads/2016/07/GuidelineButton.png" alt="GuidelineButton.png"></p>
<p>在距容器起始72dp的位置设置一个垂直的基准线，每个按钮现在可以使用基准线作为它<code>constraintStart</code>目标相同的任意点边缘对齐，<br>基准线可以有三种属性:</p>
<ul>
<li><code>layout_constraintGuide_begin</code>: 从起始边缘的绝对距离</li>
<li><code>layout_constraintGuide_end</code>: 从结束边缘的绝对距离</li>
<li><code>layout_constraintGuide_Percent</code>:从起始边缘的百分比距离</li>
</ul>
<p>从约束的角度来看,一个基准线是一个有效的目标,对于任何锚点上找到相同的轴(水平或垂直)。因此,它还必须有一个有效的id定义。</p>
<blockquote>
<p>在当前α版本,有一个bug,如果基准线在XML中出现在试图引用它的<code>view</code>的后面，约束会有不正确行为。为了解决这一问题,总是先添加您的基准线(可视化编辑器)或手动将其移动到顶部的XML</p>
</blockquote>
<h2 id="view测量"><a href="#view测量" class="headerlink" title="view测量"></a>view测量</h2><p>到目前为止我们谈了很多关于视图放置。我想花点时间来快速讨论视图大小。<code>ConstraintLayout</code>对于<code>view</code>应用稍微不同的测量规则，超出你以前使用的。有三个尺寸的定义,可以适用于任何子视图的宽度或高度:</p>
<ol>
<li><code>Exact</code>: 测量一个特定的大小(通常在dp)<ul>
<li>设置<code>layout_width</code>或<code>layout_height</code>为非零值</li>
</ul>
</li>
<li><code>Wrap Content</code>: 测量符合视图的内容<ul>
<li>设置<code>layout_width</code>或<code>layout_height</code>为<code>wrap_content</code></li>
</ul>
</li>
<li><code>Any Size</code>: 测量约束的可用空间<ul>
<li>S设置<code>layout_width</code>或<code>layout_height</code>为0dp</li>
</ul>
</li>
</ol>
<p>哇,曲线球!<code>match_parent</code>怎么了? !<code>ConstraintLayout</code>不支持它,我稍后会解释为什么。简短的版本是<code>Any Size</code>有效地取代了<code>match_parent</code>用例的方式更好的遵循的约束。</p>
<blockquote>
<p>任何试图在可视化布局编辑器添加给<code>view</code>添加<code>match_parent</code>的将被覆盖,如果你够狡猾的从XML添加，结果将产生非常尴尬的内容<code>gravity</code>和<code>positioning</code>。不要使用它。</p>
</blockquote>
<p>使用<code>Any Size</code>,我们可以要求视图拉伸轴方向附加约束。另一个例子可能吗?</p>
<pre><code>&lt;android.support.constraint.ConstraintLayout
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
  xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  android:id=&quot;@+id/constraintLayout&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;

  &lt;Button
    android:id=&quot;@+id/button_cancel&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toStartOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;/&gt;

  &lt;Button
    android:id=&quot;@+id/button_next&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:layout_constraintStart_toEndOf=&quot;@+id/button_cancel&quot;
    app:layout_constraintEnd_toEndOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot; /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p><img src="http://wiresareobsolete.com/wp-content/uploads/2016/07/AnySizeButton.png" alt="AnySizeButton.png"></p>
<p>通过设置<code>layout_width</code>为0dp,第二个按钮填充第一个按钮的结束和父容器的结束的空间。这也是类似于当前框架行为的<code>weight</code>,但使用了一个更灵活的方式。</p>
<h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>一个常见的UI布局任务是以特定的宽高比测量<code>view</code>。这是非常常见的图片,无论是广场(1:1),4:3,16:9的,或者更多的自定义。<code>ConstraintLayout</code>,你将不再需要创建一个定制的视图<code>view</code>或<code>ViewGroup</code>的子类，感谢layout_constraintDimensionRatio。</p>
<p>该功能需要<code>view</code>的一个的尺寸是“已知的”(固定尺寸或<code>wrap_content</code>)和另一个是<code>Any Size</code>(0 dp)。“<code>Any Size</code>尺寸将测量保持适当的比例通过约束设置。</p>
<pre><code>&lt;ImageView
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:src=&quot;@drawable/water&quot;
    app:layout_constraintDimensionRatio=&quot;16:9&quot;
    app:layout_constraintLeft_toLeftOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintTop_toTopOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintRight_toRightOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintVertical_bias=&quot;0.0&quot; /&gt;

  &lt;ImageView
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:src=&quot;@drawable/grass&quot;
    app:layout_constraintDimensionRatio=&quot;4:3&quot;
    app:layout_constraintLeft_toLeftOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintRight_toRightOf=&quot;@+id/constraintLayout&quot;
    app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot; /&gt;

  …​

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p>对不起<code>SquareImageView</code> <code>AspectImageView</code>,我们不需要你了…</p>
<h2 id="接下来是什么"><a href="#接下来是什么" class="headerlink" title="接下来是什么?"></a>接下来是什么?</h2><p>希望你现在对<code>ConstraintLayout</code>能干什么有一个扎实的理解，即使你没有依靠布局编辑器工具，一旦理解了语法，约束生成的XML非常简单和直观的。</p>
<p>在下一篇文章中,我们将关注<code>ConstraintLayout</code>如何处理所有这些约束来设置视图位置和大小。我们将深入其实现来理解运行时测量和布局策略。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android项目指南]]></title>
      <url>http://www.yangqinfeng.com/2016/02/11/2016-9-13-Android-guide/</url>
      <content type="html"><![CDATA[<blockquote>
<p>了解项目规范不仅能提高你自己的项目质量，而且可以帮助你学习其他符合项目规范的开源项目</p>
</blockquote>
<a id="more"></a>
<h1 id="1-Android项目指南"><a href="#1-Android项目指南" class="headerlink" title="1.Android项目指南"></a>1.Android项目指南</h1><h2 id="1-1-项目结构"><a href="#1-1-项目结构" class="headerlink" title="1.1 项目结构"></a>1.1 项目结构</h2><p>新项目应该遵守<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Project-Structure" target="_blank" rel="external">Android Gradle plugin user guide</a>定义的Android Gradle项目结构. 从开始<a href="https://github.com/ribot/android-boilerplate" target="_blank" rel="external">ribot Boilerplate</a> 项目就是一个很好的参考.</p>
<h2 id="1-2-文件命名"><a href="#1-2-文件命名" class="headerlink" title="1.2 文件命名"></a>1.2 文件命名</h2><h3 id="1-2-1-类文件"><a href="#1-2-1-类文件" class="headerlink" title="1.2.1 类文件"></a>1.2.1 类文件</h3><p>类名使用<a href="https://zh.wikipedia.org/wiki/駝峰式大小寫" target="_blank" rel="external">驼峰式大小写</a>书写.</p>
<p>对于继承Android组件的类,命名应该以组件名称结尾.例如: <code>SignInActivity</code>, <code>SignInFragment</code>, <code>ImageUploaderService</code>, <code>ChangePasswordDialog</code>.</p>
<h3 id="1-2-2-资源文件"><a href="#1-2-2-资源文件" class="headerlink" title="1.2.2 资源文件"></a>1.2.2 资源文件</h3><p>资源文件使用<strong>小写___</strong>下划线__书写.</p>
<h4 id="1-2-2-1-Drawable-文件"><a href="#1-2-2-1-Drawable-文件" class="headerlink" title="1.2.2.1 Drawable 文件"></a>1.2.2.1 Drawable 文件</h4><p><strong><em>drawables</em></strong>命名约定:</p>
<table>
<thead>
<tr>
<th>Asset Type</th>
<th>Prefix</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Action bar</td>
<td><code>ab_</code></td>
<td><code>ab_stacked.9.png</code></td>
</tr>
<tr>
<td>Button</td>
<td><code>btn_</code></td>
<td><code>btn_send_pressed.9.png</code></td>
</tr>
<tr>
<td>Dialog</td>
<td><code>dialog_</code></td>
<td><code>dialog_top.9.png</code></td>
</tr>
<tr>
<td>Divider</td>
<td><code>divider_</code></td>
<td><code>divider_horizontal.9.png</code></td>
</tr>
<tr>
<td>Icon</td>
<td><code>ic_</code></td>
<td><code>ic_star.png</code></td>
</tr>
<tr>
<td>Menu</td>
<td><code>menu_</code></td>
<td><code>menu_submenu_bg.9.png</code></td>
</tr>
<tr>
<td>Notification</td>
<td><code>notification_</code></td>
<td><code>notification_bg.9.png</code></td>
</tr>
<tr>
<td>Tabs</td>
<td><code>tab_</code></td>
<td><code>tab_pressed.9.png</code></td>
</tr>
</tbody>
</table>
<p><strong><em>icons</em></strong>命名约定:(取自<a href="http://developer.android.com/design/style/iconography.html" target="_blank" rel="external">Android iconography guidelines</a>):</p>
<table>
<thead>
<tr>
<th>Asset Type</th>
<th>Prefix</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Icons</td>
<td><code>ic_</code></td>
<td><code>ic_star.png</code></td>
</tr>
<tr>
<td>Launcher icons</td>
<td><code>ic_launcher</code></td>
<td><code>ic_launcher_calendar.png</code></td>
</tr>
<tr>
<td>Menu icons and Action Bar icons</td>
<td><code>ic_menu</code></td>
<td><code>ic_menu_archive.png</code></td>
</tr>
<tr>
<td>Status bar icons</td>
<td><code>ic_stat_notify</code></td>
<td><code>ic_stat_notify_msg.png</code></td>
</tr>
<tr>
<td>Tab icons</td>
<td><code>ic_tab</code></td>
<td><code>ic_tab_recent.png</code></td>
</tr>
<tr>
<td>Dialog icons</td>
<td><code>ic_dialog</code></td>
<td><code>ic_dialog_info.png</code></td>
</tr>
</tbody>
</table>
<p><strong><em>selector states</em></strong>命名约定:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Suffix</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal</td>
<td><code>_normal</code></td>
<td><code>btn_order_normal.9.png</code></td>
</tr>
<tr>
<td>Pressed</td>
<td><code>_pressed</code></td>
<td><code>btn_order_pressed.9.png</code></td>
</tr>
<tr>
<td>Focused</td>
<td><code>_focused</code></td>
<td><code>btn_order_focused.9.png</code></td>
</tr>
<tr>
<td>Disabled</td>
<td><code>_disabled</code></td>
<td><code>btn_order_disabled.9.png</code></td>
</tr>
<tr>
<td>Selected</td>
<td><code>_selected</code></td>
<td><code>btn_order_selected.9.png</code></td>
</tr>
</tbody>
</table>
<h4 id="1-2-2-2-布局文件（Layout-files）"><a href="#1-2-2-2-布局文件（Layout-files）" class="headerlink" title="1.2.2.2 布局文件（Layout files）"></a>1.2.2.2 布局文件（Layout files）</h4><p>布局文件应该匹配使用它们Android组件的名称并且移动组件名称到起始位置. 例如,  如果我们为 <code>SignInActivity</code> 创建了一个布局, 这个布局文件的名称应该为<code>activity_sign_in.xml</code>.</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Class Name</th>
<th>Layout Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td><code>UserProfileActivity</code></td>
<td><code>activity_user_profile.xml</code></td>
</tr>
<tr>
<td>Fragment</td>
<td><code>SignUpFragment</code></td>
<td><code>fragment_sign_up.xml</code></td>
</tr>
<tr>
<td>Dialog</td>
<td><code>ChangePasswordDialog</code></td>
<td><code>dialog_change_password.xml</code></td>
</tr>
<tr>
<td>AdapterView item</td>
<td>—</td>
<td><code>item_person.xml</code></td>
</tr>
<tr>
<td>Partial layout</td>
<td>—</td>
<td><code>partial_stats_bar.xml</code></td>
</tr>
</tbody>
</table>
<p>一个稍有不同的例子是当我们创建要被一个 <code>Adapter</code> 实现的布局, 例如填充一个<code>ListView</code> . 在这种情况下, 布局的名称应该以 <code>item_</code> 开始.</p>
<p>注意在有些情况下这些规则不可能适用.例如,当创建一个想要作为其它布局部分的布局文件.在这种情况下你应该使用前缀 <code>partial_</code>.</p>
<h4 id="1-2-2-3-菜单文件（menu-files）"><a href="#1-2-2-3-菜单文件（menu-files）" class="headerlink" title="1.2.2.3 菜单文件（menu files）"></a>1.2.2.3 菜单文件（menu files）</h4><p>和布局文件一样,菜单文件应该匹配组件名称.例如,如果我们定义一个被 <code>UserActivity</code> 使用的菜单文件,这个文件的名称应该是 <code>activity_user.xml</code></p>
<p>一个很好的实践是命名中不包含单词 <code>menu</code> 因为这些文件已经在 <code>menu</code> 目录下了.</p>
<h4 id="1-2-2-4-值文件（Values-files）"><a href="#1-2-2-4-值文件（Values-files）" class="headerlink" title="1.2.2.4 值文件（Values files）"></a>1.2.2.4 值文件（Values files）</h4><p>在值文件夹中的资源文件应该是 <strong>复数</strong>, 例如 <code>strings.xml</code>, <code>styles.xml</code>, <code>colors.xml</code>, <code>dimens.xml</code>, <code>attrs.xml</code></p>
<h1 id="2-代码指南"><a href="#2-代码指南" class="headerlink" title="2 代码指南"></a>2 代码指南</h1><h2 id="2-1-Java-语言规范"><a href="#2-1-Java-语言规范" class="headerlink" title="2.1 Java 语言规范"></a>2.1 Java 语言规范</h2><h3 id="2-1-1-不要忽略异常"><a href="#2-1-1-不要忽略异常" class="headerlink" title="2.1.1 不要忽略异常"></a>2.1.1 不要忽略异常</h3><p>永远不要写像下面的代码:</p>
<pre><code>void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) { }
}
</code></pre><p><em>尽管你认为你的代码不会遇到错误的情况或对它的处理不重要，忽略异常就像在你的代码中埋的地雷，总有一天别人会它被绊倒。原则上你必须处理你代码中的任何异常。处理方法依赖于具体情况。</em> - (<a href="https://source.android.com/source/code-style.html" target="_blank" rel="external">Android code style guidelines</a>)</p>
<blockquote>
<p>Anytime somebody has an empty catch clause they should have a creepy feeling. There are definitely times when it is actually the correct thing to do, but at least you have to think about it. In Java you can’t escape the creepy feeling. -James Gosling</p>
</blockquote>
<p>可接受的选择（按偏好排序）是:</p>
<ul>
<li><p>在调用方法中抛出异常.</p>
<pre><code>void setServerPort(String value) throws NumberFormatException {
    serverPort = Integer.parseInt(value);
}
</code></pre></li>
<li><p>抛出一个适合你抽象等级的新异常.</p>
<pre><code>void setServerPort(String value) throws ConfigurationException {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new ConfigurationException(&quot;Port &quot; + value + &quot; is not valid.&quot;);
    }
}
</code></pre></li>
<li><p>在catch｛｝块中优雅的处理错误并替换合适的值.</p>
<pre><code>/** Set port. If value is not a valid number, 80 is substituted. */

void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        serverPort = 80;  // default port for server
    }
}
</code></pre></li>
<li><p>捕获异常并抛出一个新的RutimeException，这是危险的，所以只有当你确定如果这个错误发生适当的做法是崩溃去做.</p>
<pre><code>/** Set port. If value is not a valid number, die. */

void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new RuntimeException(&quot;port &quot; + value &quot; is invalid, &quot;, e);
    }
}
</code></pre></li>
<li><p>作为最后的招数，如果你相信忽略异常是合适的然后你忽视它，但是你必须注释你为什么那样做n:</p>
<pre><code>/** If value is not a valid number, original port number is used. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        // Method is documented to just ignore invalid user input.
        // serverPort will just be unchanged.
    }
}
</code></pre></li>
</ul>
<p><a href="https://source.android.com/source/code-style.html#dont-ignore-exceptions" target="_blank" rel="external">官网原文</a>.</p>
<h3 id="2-1-2-不要捕获通用异常"><a href="#2-1-2-不要捕获通用异常" class="headerlink" title="2.1.2 不要捕获通用异常"></a>2.1.2 不要捕获通用异常</h3><p>永远不要写像下面的代码:</p>
<pre><code>try {
    someComplicatedIOFunction();        // may throw IOException
    someComplicatedParsingFunction();   // may throw ParsingException
    someComplicatedSecurityFunction();  // may throw SecurityException
    // phew, made it all the way
} catch (Exception e) {                 // I&apos;ll just catch all exceptions
    handleError();                      // with one generic handler!
}
</code></pre><p>不要这么做，在几乎所有的情况下捕获或抛出泛型异常是不合适。这样做是很危险的，因为那意味着你没有预料到的异常（包括运行时异常像类转换异常）被应用级的错误处理捕获，它使你处理特性的失败的代码费解，这意味着如果某人在你调用的的代码中添加新类型的异常，编译器不会帮你识别你需要处理错误不同，在大多数情况下你不应该用同样的方法处理不同类型的异常。</p>
<p>少见的例外是测试代码和顶级的代码在那里你想处理所有类型的错误（阻止它们在UI展现，或保持一批工作运行）。在这些例子中你可以捕获泛型异常（或抛出）并适当的处理这些错误，在你做这些之前仔细思考，并在这个地方加入注释解释为什么是安全的。</p>
<p>捕获泛型异常的可选方法</p>
<ul>
<li><p>在一个try之后分别捕获每个异常作为分开的catch块，这可能是难对付的但仍然是比捕获所有异常更好，注意在catch块中重复太多的代码。</p>
</li>
<li><p>重构你的代码使其有更细致的有多个try块的错误处理，从解析过程分离IO，对于每种情况分别处理错误。</p>
</li>
<li><p>重新抛出这个异常，很多时候你不需要在这一级捕获这个异常，只让方法抛出它。</p>
</li>
</ul>
<p>记住：异常是你的朋友，当编译器抱怨你没有捕获时，不要怒容。微笑着：编译器只是为了你在你代码中捕获运行时异常问题更容易。</p>
<p><a href="https://source.android.com/source/code-style.html#dont-catch-generic-exception" target="_blank" rel="external">官网原文</a></p>
<h3 id="2-1-3-不要使用finalizers"><a href="#2-1-3-不要使用finalizers" class="headerlink" title="2.1.3 不要使用finalizers"></a>2.1.3 不要使用finalizers</h3><p><em>不要使用finalizers，这里没有保证当一个finalizer会被调用，或者尽管它会被调用，在大多数情况下，你可以用一个合适的异常处理做你需要在finalizer中的事情。如果你显然需要它，定义一个close（）方法并且在方法需要被调用时明确记录（学习InputStream），在这种情况下它是合适的但是不求从finalizer打印一个简短的日志消息，因为它不希望日志太多。</em> - (<a href="https://source.android.com/source/code-style.html#dont-use-finalizers" target="_blank" rel="external">Android code style guidelines</a>)</p>
<h3 id="2-1-4-全限定导入"><a href="#2-1-4-全限定导入" class="headerlink" title="2.1.4 全限定导入"></a>2.1.4 全限定导入</h3><p>坏的做法: <code>import foo.*;</code></p>
<p>好的做法: <code>import foo.Bar;</code></p>
<p>更多看 <a href="https://source.android.com/source/code-style.html#fully-qualify-imports" target="_blank" rel="external">这里</a></p>
<h2 id="2-2-Java-风格规范"><a href="#2-2-Java-风格规范" class="headerlink" title="2.2 Java 风格规范"></a>2.2 Java 风格规范</h2><h3 id="2-2-1-域定义和命名"><a href="#2-2-1-域定义和命名" class="headerlink" title="2.2.1 域定义和命名"></a>2.2.1 域定义和命名</h3><p>域应该定义在<strong>文件的顶部</strong>并且遵守下面列表的命名规则.</p>
<ul>
<li>Private, non-static 域的名称以 <strong>m</strong> 开始.</li>
<li>Private, static 域的名称以 <strong>s</strong> 开始.</li>
<li>其他域以小写字母开始.</li>
<li>Static final 域 (常量) 是 ALL_CAPS_WITH_UNDERSCORES（全大写用下划线分割）.</li>
</ul>
<p>Example:</p>
<pre><code>public class MyClass {
    public static final int SOME_CONSTANT = 42;
    public int publicField;
    private static MyClass sSingleton;
    int mPackagePrivate;
    private int mPrivate;
    protected int mProtected;
}
</code></pre><h3 id="2-2-3-对待缩略词像单词一样"><a href="#2-2-3-对待缩略词像单词一样" class="headerlink" title="2.2.3 对待缩略词像单词一样"></a>2.2.3 对待缩略词像单词一样</h3><table>
<thead>
<tr>
<th>Good</th>
<th>Bad</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>XmlHttpRequest</code></td>
<td><code>XMLHTTPRequest</code></td>
</tr>
<tr>
<td><code>getCustomerId</code></td>
<td><code>getCustomerID</code></td>
</tr>
<tr>
<td><code>String url</code></td>
<td><code>String URL</code></td>
</tr>
<tr>
<td><code>long id</code></td>
<td><code>long ID</code></td>
</tr>
</tbody>
</table>
<h3 id="2-2-4-使用空格缩颈"><a href="#2-2-4-使用空格缩颈" class="headerlink" title="2.2.4 使用空格缩颈"></a>2.2.4 使用空格缩颈</h3><p>对块使用<strong>4空格</strong>缩颈:</p>
<pre><code>if (x == 1) {
    x++;
}
</code></pre><p>行内换行使用<strong>8空格</strong>:</p>
<pre><code>Instrument i =
        someLongExpression(that, wouldNotFit, on, one, line);
</code></pre><h3 id="2-2-5-使用标准大括号风格"><a href="#2-2-5-使用标准大括号风格" class="headerlink" title="2.2.5 使用标准大括号风格"></a>2.2.5 使用标准大括号风格</h3><p>在同行代码之后使用大括号｛.</p>
<pre><code>class MyClass {
    int func() {
        if (something) {
            // ...
        } else if (somethingElse) {
            // ...
        } else {
            // ...
        }
    }
}
</code></pre><p>大括号包住语句是必须的除非条件和主体固定在一行.</p>
<p>如果条件和主体固定在一行而且比最大行长度短，大括号不是必须的, 例如</p>
<pre><code>if (condition) body();
</code></pre><p><strong>坏的</strong>做法:</p>
<pre><code>if (condition)
    body();  // bad!
</code></pre><h3 id="2-2-6-注释（Annotations）"><a href="#2-2-6-注释（Annotations）" class="headerlink" title="2.2.6 注释（Annotations）"></a>2.2.6 注释（Annotations）</h3><h4 id="2-2-6-1-注释实践"><a href="#2-2-6-1-注释实践" class="headerlink" title="2.2.6.1 注释实践"></a>2.2.6.1 注释实践</h4><p>根据Android编码风格指南，对于java中预定义的一些注释的标志实践是:</p>
<ul>
<li><p><code>@Override</code>: 每当方法覆盖父类中的声明或实现，<code>@Override</code>注释必须使. 例如, 如果你使用<code>@inheritdocs</code> Javadoc 标签, 并且从一个类（不是一个借口）派生, 你也必须注释方法<code>@Overrides</code>父类方法.</p>
</li>
<li><p><code>@SuppressWarnings</code>: <code>@SuppressWarnings</code> 注释应该只被用于不可能消除一个警告的情况下. If a warning passes this “impossible to eliminate” test如果一个警告通过了这个“不可能消除”的测试, <code>@SuppressWarnings</code> 注释必须被使用,以确保所用的警告反应了代码中的真实的问题.</p>
</li>
</ul>
<p>更多内容<a href="http://source.android.com/source/code-style.html#use-standard-java-annotations" target="_blank" rel="external">官网</a>.</p>
<h4 id="2-2-6-2-注释风格"><a href="#2-2-6-2-注释风格" class="headerlink" title="2.2.6.2 注释风格"></a>2.2.6.2 注释风格</h4><p><strong>类,方法和构造器</strong></p>
<p>当注释被应用于类，方法或构造器, 它们在文档块被列出来并且应该呈现<strong>每行一个注释</strong>.</p>
<pre><code>/* This is the documentation block about the class */
@AnnotationA
@AnnotationB
public class MyAnnotatedClass { }
</code></pre><p><strong>域</strong></p>
<p>应用于域的注释应该在<strong>同一行</strong>列出来, 除非达到最大行长度.</p>
<pre><code>@Nullable @Mock DataManager mDataManager;
</code></pre><h3 id="2-2-7-限定变量作用域"><a href="#2-2-7-限定变量作用域" class="headerlink" title="2.2.7 限定变量作用域"></a>2.2.7 限定变量作用域</h3><p><em>局部变量的作用域应该保持到最小(Effective Java Item 29). 这样做, 你可以提高你代码的可读性和可维护性并且减少可能发生的错误. 每个变量应该在所有使用它闭包的最里面的块中声明.</em></p>
<p><em>局部变量应该在它们第一次使用的地方声明. 几乎每个局部变量声明应该包含初始化.如果你没有足够的信息的合理地初始化变量, 你应该推迟声明直到你可以.</em> - (<a href="https://source.android.com/source/code-style.html#limit-variable-scope" target="_blank" rel="external">Android code style guidelines</a>)</p>
<h3 id="2-2-8-导入语句排序"><a href="#2-2-8-导入语句排序" class="headerlink" title="2.2.8 导入语句排序"></a>2.2.8 导入语句排序</h3><p>如果你使用的IDE是Android Studio，你不必担心因为你的IDE已经遵守这些规则，如果不是，看下面.</p>
<p>导入语句排序:</p>
<ol>
<li>Android imports</li>
<li>Imports from third parties (com, junit, net, org)</li>
<li>java and javax</li>
<li>Same project imports</li>
</ol>
<p>To exactly match the IDE settings, the imports should be:</p>
<ul>
<li>Alphabetically ordered within each grouping, with capital letters before lower case letters (e.g. Z before a).</li>
<li>There should be a blank line between each major grouping (android, com, junit, net, org, java, javax).</li>
</ul>
<p>更多 <a href="https://source.android.com/source/code-style.html#limit-variable-scope" target="_blank" rel="external">官网</a></p>
<h3 id="2-2-9-Logging-指南"><a href="#2-2-9-Logging-指南" class="headerlink" title="2.2.9 Logging 指南"></a>2.2.9 Logging 指南</h3><p>建议使用<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">timber</a></p>
<p>尽管logging 是很必要的，但是它对性能有负面影响并且你如果不保持logiong合理地简明扼要就会很快失去价值。logging工具提供五种不同级别的logging：</p>
<ul>
<li>ERROR：当发生致命的事情时使用</li>
<li>WARNING：当发生意料之外的严重事情时使用</li>
<li>INFORMATIVE：当发生人们关心的事情时使用</li>
<li>DEBUG：用于进一步指出我们的机器发生了什么有关我们想审查和调试意料之外的行为</li>
<li>VERBOSE：用于其他任何情况</li>
</ul>
<p>使用<code>Log</code>类提供的日志方法打印错误信息或其他用于开发者找出问题的信息:</p>
<ul>
<li><code>Log.v(String tag, String msg)</code> (verbose)</li>
<li><code>Log.d(String tag, String msg)</code> (debug)</li>
<li><code>Log.i(String tag, String msg)</code> (information)</li>
<li><code>Log.w(String tag, String msg)</code> (warning)</li>
<li><code>Log.e(String tag, String msg)</code> (error)</li>
</ul>
<p>作为一个普遍规则,我们使用类名作为标签并且我们在文件顶部定义它作为<code>static final</code>. 例如:</p>
<pre><code>public class MyClass {
    private static final String TAG = &quot;MyClass&quot;;

    public myMethod() {
        Log.e(TAG, &quot;My error message&quot;);
    }
}
</code></pre><p>VERBOSE 和 DEBUG logs在发布构建时必须被禁用. 也建议发布构建时禁用INFORMATION, WARNING 和 ERROR logs但是你也许想保持它们可用如果你认为它们有助于找出问题. 如果你觉得使它们可用,你必须确认它们没有泄漏私人信息,像邮箱地址,用户id，等等.</p>
<p>只在调试构建时展现logs:</p>
<pre><code>if (BuildConfig.DEBUG) Log.d(TAG, &quot;The value of x is &quot; + x);
</code></pre><h3 id="2-2-10-类成员排序"><a href="#2-2-10-类成员排序" class="headerlink" title="2.2.10 类成员排序"></a>2.2.10 类成员排序</h3><p>这里没要唯一正确的解决方案但是使用<strong>逻辑性</strong>和<strong>一致</strong>的顺序会提高代码的可学习性和可阅读性，推荐使用下面这种顺序:</p>
<ol>
<li>常量</li>
<li>域</li>
<li>构造器</li>
<li>覆盖方法或回调</li>
<li>公有方法</li>
<li>私有方法</li>
<li>内部类或内部接口</li>
</ol>
<p>例子:</p>
<pre><code>public class MainActivity extends Activity {

    private String mTitle;
    private TextView mTextViewTitle;

    public void setTitle(String title) {
        mTitle = title;
    }

    @Override
    public void onCreate() {
        ...
    }

    private void setUpView() {
        ...
    }

    static class AnInnerClass {

    }

}
</code></pre><p>如果你的类继承像一个<code>Activity</code>或<code>Fragment</code>的Android组件, 排序覆盖方法以致于它们<strong>匹配组件的生命周期</strong>是一个很好的实践. 例如, 如果你有一个<code>Activity</code>实现 <code>onCreate()</code>, <code>onDestroy()</code>, <code>onPause()</code> 和 <code>onResume()</code>, 正确的顺序是:</p>
<pre><code>public class MainActivity extends Activity {

    //Order matches Activity lifecycle
    @Override
    public void onCreate() {}

    @Override
    public void onResume() {}

    @Override
    public void onPause() {}

    @Override
    public void onDestroy() {}

}
</code></pre><h3 id="2-2-11-方法中参数排序"><a href="#2-2-11-方法中参数排序" class="headerlink" title="2.2.11 方法中参数排序"></a>2.2.11 方法中参数排序</h3><p>在Android编程中, 方法定义中带有<code>Context</code>是非常常见的. 如果你写的方法像它一样, <strong>Context</strong> 必须是<strong>第一个</strong>参数.</p>
<p>相反的例子是 <strong>callback</strong> 接口应该是<strong>最后一个</strong>参数 .</p>
<p>例子:</p>
<pre><code>// Context always goes first
public User loadUser(Context context, int userId);

// Callbacks always go last
public void loadUserAsync(Context context, int userId, UserCallback callback);
</code></pre><h3 id="2-2-13-字符串常量-命名-和值"><a href="#2-2-13-字符串常量-命名-和值" class="headerlink" title="2.2.13 字符串常量, 命名, 和值"></a>2.2.13 字符串常量, 命名, 和值</h3><p>Android SDK中许多元素像<code>SharedPreferences</code>, <code>Bundle</code>, 或 <code>Intent</code> 使用一个键-值对的方法,因此很可能即使是一个小应用程序你最终不得不写大量的字符串常量 .</p>
<p>当使用这些组件中的一个时, 你必须定义键为一个 <code>static final</code> 域并且它们应该加前缀,如下表示.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Field Name Prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>SharedPreferences</td>
<td><code>PREF_</code></td>
</tr>
<tr>
<td>Bundle</td>
<td><code>BUNDLE_</code></td>
</tr>
<tr>
<td>Fragment Arguments</td>
<td><code>ARGUMENT_</code></td>
</tr>
<tr>
<td>Intent Extra</td>
<td><code>EXTRA_</code></td>
</tr>
<tr>
<td>Intent Action</td>
<td><code>ACTION_</code></td>
</tr>
</tbody>
</table>
<p>注意Fragment的参数- <code>Fragment.getArguments()</code> - 也是一个<strong>Bundle</strong>. 尽管如此, 因为这是<strong>Bundles</strong>的一种相当普遍的用法, 我们为它们定义不同的前缀.</p>
<p>例如:</p>
<pre><code>// Note the value of the field is the same as the name to avoid duplication issues
static final String PREF_EMAIL = &quot;PREF_EMAIL&quot;;
static final String BUNDLE_AGE = &quot;BUNDLE_AGE&quot;;
static final String ARGUMENT_USER_ID = &quot;ARGUMENT_USER_ID&quot;;

// Intent-related items use full package name as value
static final String EXTRA_SURNAME = &quot;com.myapp.extras.EXTRA_SURNAME&quot;;
static final String ACTION_OPEN_USER = &quot;com.myapp.action.ACTION_OPEN_USER&quot;;
</code></pre><h3 id="2-2-14-Fragments-和-Activities中的参数"><a href="#2-2-14-Fragments-和-Activities中的参数" class="headerlink" title="2.2.14 Fragments 和 Activities中的参数"></a>2.2.14 Fragments 和 Activities中的参数</h3><p>当数据通过一个 <code>Intent</code> 或 <code>Bundle</code>传递给一个<code>Activity</code>or <code>Fragment</code>, 对于不同值的键必须遵循上面部分的规则.</p>
<p>当一个<code>Activity</code> 或 <code>Fragment</code> 预期参数, 它应该提供一个 <code>public static</code> 方法使有关<code>Intent</code> 或 <code>Fragment</code>创建更方便.</p>
<p>在Activities这个方法通常叫 <code>getStartIntent()</code>:</p>
<pre><code>public static Intent getStartIntent(Context context, User user) {
    Intent intent = new Intent(context, ThisActivity.class);
    intent.putParcelableExtra(EXTRA_USER, user);
    return intent;
}
</code></pre><p>对于Fragments命名为 <code>newInstance()</code> 并且用正确的参数处理Fragment的创建:</p>
<pre><code>public static UserFragment newInstance(User user) {
    UserFragment fragment = new UserFragment;
    Bundle args = new Bundle();
    args.putParcelable(ARGUMENT_USER, user);
    fragment.setArguments(args)
    return fragment;
}
</code></pre><p><strong>Note 1</strong>:  这些方法应该位于类的顶部在 <code>onCreate()</code> 之前.</p>
<p><strong>Note 2</strong>: 如果我们提供上述方法,对于extras 和arguments的键应该是 <code>private</code> 因为不需要暴露它们给外部类.</p>
<h3 id="2-2-15-行长度限制"><a href="#2-2-15-行长度限制" class="headerlink" title="2.2.15 行长度限制"></a>2.2.15 行长度限制</h3><p>代码长度不应该超过<strong>100个</strong>字符，如果超过这个限制通常有两种选择来减少长度:</p>
<ul>
<li>抽象为一个局部变量或方法（推荐）.</li>
<li>使用换行把一行分为多行.</li>
</ul>
<p>这儿有两种<strong>例外</strong>可能行长度超过100:</p>
<ul>
<li>行不可能分割，例如注释中的长URL.</li>
<li><code>package</code> 和 <code>import</code> 语句.</li>
</ul>
<h4 id="2-2-15-1-换行策略"><a href="#2-2-15-1-换行策略" class="headerlink" title="2.2.15.1 换行策略"></a>2.2.15.1 换行策略</h4><p>这里不是一个精确的方式解释如何自动换行和不同的解决方案是有效的. 但是有一些规则可以适用于一般情况下.</p>
<p><strong>在操作符截断</strong></p>
<p>当行在操作符处截断, 截断出现在操作符之前. 例如:</p>
<pre><code>int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne
        + theFinalOne;
</code></pre><p><strong>赋值操作符例外</strong></p>
<p>An exception to the <code>break at operators</code> rule is the assignment operator <code>=</code>, where the line break should happen <strong>after</strong> the operator.</p>
<pre><code>int longName =
        anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne;
</code></pre><p><strong>方法链</strong></p>
<p>当多个方法在同一行被串起来 - 比如使用Builders - 每个方法调用应该在 <code>.</code> 之前另起一行</p>
<pre><code>Picasso.with(context).load(&quot;http://ribot.co.uk/images/sexyjoe.jpg&quot;).into(imageView);


Picasso.with(context)
        .load(&quot;http://ribot.co.uk/images/sexyjoe.jpg&quot;)
        .into(imageView);
</code></pre><p><strong>长参数</strong></p>
<p>当一个方法有许多参数或它的参数非常长, 我们应该在每个<code>,</code>之后截断行</p>
<pre><code>loadPicture(context, &quot;http://ribot.co.uk/images/sexyjoe.jpg&quot;, mImageViewProfilePicture, clickListener, &quot;Title of the picture&quot;);


loadPicture(context,
        &quot;http://ribot.co.uk/images/sexyjoe.jpg&quot;,
        mImageViewProfilePicture,
        clickListener,
        &quot;Title of the picture&quot;);
</code></pre><h3 id="2-2-16-RxJava-链风格"><a href="#2-2-16-RxJava-链风格" class="headerlink" title="2.2.16 RxJava 链风格"></a>2.2.16 RxJava 链风格</h3><p>Rx链操作符需要换行. 每个操作符必须另起一行并且行应该在<code>.</code>之前截断</p>
<pre><code>public Observable&lt;Location&gt; syncLocations() {
    return mDatabaseHelper.getAllLocations()
            .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() {
                @Override
                 public Observable&lt;? extends Location&gt; call(Location location) {
                     return mRetrofitService.getLocation(location.id);
                 }
            })
            .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() {
                 @Override
                 public Boolean call(Integer numRetries, Throwable throwable) {
                     return throwable instanceof RetrofitError;
                 }
            });
}
</code></pre><h2 id="2-3-XML-风格规范"><a href="#2-3-XML-风格规范" class="headerlink" title="2.3 XML 风格规范"></a>2.3 XML 风格规范</h2><h3 id="2-3-1-使用自闭和标签"><a href="#2-3-1-使用自闭和标签" class="headerlink" title="2.3.1 使用自闭和标签"></a>2.3.1 使用自闭和标签</h3><p>当一个XML元素没有任何内容, 你<strong>必须</strong>使用自闭和标签.</p>
<p><strong>好</strong>的做法:</p>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_view_profile&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p><strong>坏</strong>的做法 :</p>
<pre><code>&lt;!-- Don\&apos;t do this! --&gt;
&lt;TextView
    android:id=&quot;@+id/text_view_profile&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; &gt;
&lt;/TextView&gt;
</code></pre><h3 id="2-3-2-资源命名"><a href="#2-3-2-资源命名" class="headerlink" title="2.3.2 资源命名"></a>2.3.2 资源命名</h3><p>资源IDs和命名使用 <strong>小写_下划线</strong>.</p>
<h4 id="2-3-2-1-ID-命名"><a href="#2-3-2-1-ID-命名" class="headerlink" title="2.3.2.1 ID 命名"></a>2.3.2.1 ID 命名</h4><p>IDs 应该以元素名称作为前缀. 例如:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TextView</code></td>
<td><code>text_</code></td>
</tr>
<tr>
<td><code>ImageView</code></td>
<td><code>image_</code></td>
</tr>
<tr>
<td><code>Button</code></td>
<td><code>button_</code></td>
</tr>
<tr>
<td><code>Menu</code></td>
<td><code>menu_</code></td>
</tr>
</tbody>
</table>
<p>Image view 例子:</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/image_profile&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>Menu 例子:</p>
<pre><code>&lt;menu&gt;
    &lt;item
        android:id=&quot;@+id/menu_done&quot;
        android:title=&quot;Done&quot; /&gt;
&lt;/menu&gt;
</code></pre><h4 id="2-3-2-2-字符串"><a href="#2-3-2-2-字符串" class="headerlink" title="2.3.2.2 字符串"></a>2.3.2.2 字符串</h4><p>字符串命名起始前缀用于区分它们属于的部分. 例如 <code>registration_email_hint</code> 或<code>registration_name_hint</code>. 如果字符串<strong>不属于</strong>任何部分, 你应该遵守下面这些规则:</p>
<table>
<thead>
<tr>
<th>Prefix</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>error_</code></td>
<td>An error message</td>
</tr>
<tr>
<td><code>msg_</code></td>
<td>A regular information message</td>
</tr>
<tr>
<td><code>title_</code></td>
<td>A title, i.e. a dialog title</td>
</tr>
<tr>
<td><code>action_</code></td>
<td>An action such as “Save” or “Create”</td>
</tr>
</tbody>
</table>
<h4 id="2-3-2-3-Styles-and-Themes"><a href="#2-3-2-3-Styles-and-Themes" class="headerlink" title="2.3.2.3 Styles and Themes"></a>2.3.2.3 Styles and Themes</h4><p>除非其他资源,style名字使用<strong>驼峰式大小写</strong>.</p>
<h3 id="2-3-3-属性排序"><a href="#2-3-3-属性排序" class="headerlink" title="2.3.3 属性排序"></a>2.3.3 属性排序</h3><p>作为一个普遍的规则你应该试图把相似的属性组织在一起. 对于最普遍属性一个好的排序方法:</p>
<ol>
<li>View Id</li>
<li>Style</li>
<li>Layout width and layout height</li>
<li>Other layout attributes, sorted alphabetically（字母序）</li>
<li>Remaining attributes, sorted alphabetically</li>
</ol>
<h2 id="2-4-测试风格规范"><a href="#2-4-测试风格规范" class="headerlink" title="2.4 测试风格规范"></a>2.4 测试风格规范</h2><h3 id="2-4-1-单元测试"><a href="#2-4-1-单元测试" class="headerlink" title="2.4.1 单元测试"></a>2.4.1 单元测试</h3><p>测试类应该匹配测试目标类的名字,加上 <code>Test</code>. 例如, 如果我们创建一个包含测试<code>DatabaseHelper</code>测试类, 我们应该命名它为 <code>DatabaseHelperTest</code>.</p>
<p>测试方法被 <code>@Test</code> 注释并且通常应该以被测试方法的名称开始, 加上前置条件和/或 预期行为.</p>
<ul>
<li>模版: <code>@Test void methodNamePreconditionExpectedBehaviour()</code></li>
<li>例子: <code>@Test void signInWithEmptyEmailFails()</code></li>
</ul>
<p>前置条件和/或预期的行为并不总是需要如果测试足够清晰没有它们.</p>
<p>有时一个类可能包含大量方法, 同时对于每个方法需要多个测试. 在这种情况下, 分割一个测试类到多个测试类是一个值得推荐的. 例如, 如果 <code>DataManager</code> 包含大量方法我们想要分到 <code>DataManagerSignInTest</code>, <code>DataManagerLoadUsersTest</code>, 等等. 通常你可以看到测试属于彼此,因为他们有共同的<a href="https://en.wikipedia.org/wiki/Test_fixture" target="_blank" rel="external">test fixtures</a>.</p>
<h3 id="2-4-2-Espresso-测试"><a href="#2-4-2-Espresso-测试" class="headerlink" title="2.4.2 Espresso 测试"></a>2.4.2 Espresso 测试</h3><p>每个Espresso测试类通常目标是一个Activity,因此名称应该匹配目标Activity的名称加上 <code>Test</code>, 例如 <code>SignInActivityTest</code></p>
<p>当使用Espresso API时链方法另起一行是普遍的实践.</p>
<pre><code>onView(withId(R.id.view))
        .perform(scrollTo())
        .check(matches(isDisplayed()))
</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 开发文化quality matters]]></title>
      <url>http://www.yangqinfeng.com/2016/02/05/2016-01-20-android-%E5%BC%80%E5%8F%91%E6%96%87%E5%8C%96QualityMatter/</url>
      <content type="html"><![CDATA[<p>Android 开发有问题（在过去的7年）。大多数项目没有测试（单元，集成，功能); 编译器和lint的警告被忽视; 代码像臭的意大利面条。</p>
<p>坏消息: Google从一开始就参与这样的Android开发文化。</p>
<blockquote class="blockquote-center"><p>perfmatters VS qualitymatters</p>
</blockquote>
<p>是的，google 关心perfmatters，但是qualitymatters更重要并且应该优先考虑。</p>
<blockquote>
<p>Optimization without a good level of code quality is a kind of premature optimization，premature optimization is also known as the root of all evil (not in all situations，but mostly it is evil)。</p>
</blockquote>
<p>好消息: 公司像Square，SoundCloud，Twitter和一些开发者通过做演讲，写博客使Android 开发更好，非常感谢他们。同时，谷歌终于对提高Android应用程序质量感兴趣: 在 AndroidDevSummit 和其他近期会议我们看见关于测试的内容，请继续保持!</p>
<p><strong>是时候搞定Android开发了</strong>。<br><a id="more"></a></p>
<h2 id="Android-开发文化"><a href="#Android-开发文化" class="headerlink" title="Android 开发文化"></a>Android 开发文化</h2><h3 id="尽快失败，尽早失败（Fail-fast，fail-early）"><a href="#尽快失败，尽早失败（Fail-fast，fail-early）" class="headerlink" title="尽快失败，尽早失败（Fail fast，fail early）"></a><strong>尽快失败，尽早失败（Fail fast，fail early</strong>）</h3><p>为什么?–因为如果你能在集成到用户产品之前发现问题—-你应该那样做。这个文档的每一项都遵守这个原则。</p>
<h3 id="Pull-Requests，代码审查（Code-Review-持续集成（Continuous-Integration）"><a href="#Pull-Requests，代码审查（Code-Review-持续集成（Continuous-Integration）" class="headerlink" title="Pull Requests，代码审查（Code Review),持续集成（Continuous Integration）"></a><strong>Pull Requests，代码审查（Code Review),持续集成（Continuous Integration）</strong></h3><p>项目应该在版本控制系统下开发，开发过程应该发生通过Pull Requests进行<br>代码审查，没有什么应该被直接推到主分支，每个PR应该在持续集成系统触发build项目活动。 build应该是可复制的，团队中的每个成员能方便的build项目。</p>
<p>尽早失败：如果一个PR在CI上build失败–这个PR不应该到被修复。</p>
<h3 id="代码质量（Code-quality）"><a href="#代码质量（Code-quality）" class="headerlink" title="代码质量（Code quality）"></a><strong>代码质量（Code quality）</strong></h3><p>你的代码应该是<a href="https://en。wikipedia。org/wiki/SOLID_(object-oriented_design" target="_blank" rel="external">SOLID</a>，或者接近SOLID。这完全是取决于你如何实现这一点。这不仅是 <a href="https://en。wikipedia。org/wiki/Model–view–presenter" target="_blank" rel="external">MVP</a>/<a href="https://en。wikipedia。org/wiki/Model–view–viewmodel" target="_blank" rel="external">MVVM</a>/<a href="https://en。wikipedia。org/wiki/Model–view–controller" target="_blank" rel="external">MVC</a>/等，而且是在你应用每部分的每段代码。宁愿写<a href="https://en。wikipedia。org/wiki/Pure_function" target="_blank" rel="external">纯函数</a>和<a href="https://en。wikipedia。org/wiki/Immutable_object" target="_blank" rel="external">不变对象</a>。</p>
<p>尽早失败：不要只成为在项目中写可维护代码的开发者，也要确定其他人写好的代码（和他们聊聊，讨论这个文档，督促他们）－在代码审查阶段阻止坏的代码。</p>
<h3 id="静态代码-资源分析（Static-Code-Resources-Analysis）"><a href="#静态代码-资源分析（Static-Code-Resources-Analysis）" class="headerlink" title="静态代码/资源分析（Static Code/Resources Analysis）"></a><strong>静态代码/资源分析</strong>（Static Code/Resources Analysis）</h3><p>分析允许你在你集成到产品之前找到你代码中的问题。 另一方面它有助于代码审查。</p>
<p>Android Lint，FindBugs，PMD，SonarQube，FB Infer，etc。</p>
<p>尽早失败:在CI期间运行静态分析器并配置它在项目有警告（不止是错误）的情况下 build 失败。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h3><p>是的，测试，单元测试通常检查函数／对象是否正常地工作，在你项目中越多测试和高代码覆盖率–你给用户的产品就更好更稳定。事实上，绝大多数简单的bugs可以通过单元测试找到，并且当然你的应用有数据处理–单元测试会帮助你确定你的代码是否正确工作。</p>
<p>一个简短的Android项目单元测试指南:</p>
<ul>
<li>试着在JVM上运行单元测试因为这样比在设备／虚拟机上运行快的多。</li>
<li>Android Gradle Plugin能在JVM上运行单元测试。 只要把你的测试代码放在test／<code>java_or_other_lang</code>。</li>
<li>你可以从IDE（在test右击并执行run）运行测试或者在Terminal执行<code>。/gradlew test</code></li>
<li>你很快认识到如果在JVM运行你的使用Android SDK类的单元测试，Android SDK类是不存在并且会抛出异常。这是悲伤但可以解决的。你可以在Robolectric test runner 下运行需要Android SDK的测试，Robolectrie会提供你工作的大多数Android SDK类的实现。</li>
<li>JUnit 提供好的运行器和相当好的规则概念，但是JUnit断言很糟糕，你可以通过AssertJ，Truth等使用更好的断言并且在JUnit(or TestNG/Spock/etc)下面运行</li>
<li>如果你需要检查行为并且Mock一些对象－你可以使用像Mockito这样的mocking库<blockquote>
<p>测试驱动开发或别的－由你决定，但是当然要试一试。 </p>
</blockquote>
</li>
</ul>
<p>尽早失败:在CI期间运行单元测试，当一些测试失败时则 build 失败。 </p>
<h3 id="代码覆盖率（Code-Coverage）"><a href="#代码覆盖率（Code-Coverage）" class="headerlink" title="代码覆盖率（Code Coverage）"></a><strong>代码覆盖率</strong>（Code Coverage）</h3><p>一旦你开始编写单元测试你需要知道你的代码覆盖率是否足够好。 你可以使用像Jacoco这样的工具检查测试所覆盖的代码路径。 如果你测试代码的行为取决于一些条件，代码覆盖率是特别有用，并且你需要确保所有可能的变体代码执行的检查。</p>
<p>你可以启用Jacoco通过apply plugin: ‘jacoco’。 你可以通过Gradle task配置应该检查的类/包。</p>
<p>如果覆盖率不够高，配置代码覆盖率的工具使build失败。 如果你在一个现有的项目开始单元测试-排除没有测试的类-一旦你用测试覆盖它们然后把它们从排除列表移除。 这个规则会帮助你确定新代码覆盖的足够好。 你可以使用jacoco-coverage插件根据覆盖率报告使build失败。</p>
<p>尽早失败: 如果代码覆盖率不够广，则 build 失败，确定在CI期间检查代码覆盖率。</p>
<h3 id="功能测试（Functional-UI-tests）"><a href="#功能测试（Functional-UI-tests）" class="headerlink" title="功能测试（Functional (UI) tests）"></a><strong>功能测试</strong>（Functional (UI) tests）</h3><p>是的。 更多测试。 功能测试是从用户角度检查你应用的功能。 功能测试启动你的应用并且验证你核心的特性是否正确工作。 例如加载数据在UI显示等等。 你的QA团队来做大部分工作能通过功能测试自动化，但这并不意味着你不需要QA团队。</p>
<p>这里有两种运行功能测试的普通方法。 你可以在 Android Instrumentation 或 UIAutomator下运行它们。 主要的不同是在Android Instrumentation 下的测试只能在你的应用下面工作，它们可以接触到你的代码等等。 在 UIAutomator下的测试运行在系统进程并可以通过可用API（比 Android Instrumentation的能力更有限）与你的应用交互。 如果你需要测试你应用与其它应用的交互－你可以使用UIAutomator，但是通常你可以模拟这样的交互并且通过 Android Instrumentation测试它们，你的测试不会依赖外部因素</p>
<p>建议:</p>
<ul>
<li>使用 Android Instrumentation 和 Espresso。</li>
<li>面向页面架构的测试会帮助你写和维护测试更容易，更快（i。e。 当你有一个描述你应用中屏幕或部分屏幕页面类）</li>
<li>模拟与后端的交互，它会使你的测试完全独立，并且你能并行的运行测试 ，并确信你在测试之间没有共享状态，在这里 MockWebServer 是一个好的助手</li>
<li>开发者应该写功能测试，是的</li>
<li>教你的QA团队写功能测试－通常QAs思考不同并且知道哪种情况需要被检查</li>
<li>检查功能测试的代码覆盖率</li>
</ul>
<p>尽早失败:在CI期间运行功能测试，当一些测试失败时则 build 失败。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a><strong>集成测试</strong></h3><p>是的。 更多测试。 通常，集成测试检查你的组件在一起工作的时候有什么不同:HTTP layer，REST API layer，Execution layer (RxJava，etc)等等。 </p>
<p>想象你有一个类使用了一组其它类并且从后台加载数据，接下来处理它并且储存在数据库，你应该用单元测试覆盖每个类，但是你也能用集成覆盖如此复杂的组合。</p>
<p>这里与单元测试的主要不同是你不需要模拟对象，而是测试中真的实现对象。你可以模拟数据传递和数据库状态然后运行真实代码来看它会如何做它的工作。</p>
<p>你可以在设备/虚拟机在 Android Instrumentation下运行集成测试或者在JVM作为单元测试的部分，因为测试在JVM上运行的更快－使用JVM。</p>
<p>尽早失败:在CI期间运行集成测试，当一些测试失败时则 build 失败。</p>
<h3 id="开发者设置菜单-aka-Debug-Drawer"><a href="#开发者设置菜单-aka-Debug-Drawer" class="headerlink" title="开发者设置菜单 (aka Debug Drawer)"></a><strong>开发者设置菜单</strong> (aka Debug Drawer)</h3><p>你调试build时这种菜单允许你enable/disable工具像 <a href="http://facebook。github。io/stetho/" target="_blank" rel="external">Stetho</a>，<a href="https://github。com/square/leakcanary" target="_blank" rel="external">LeakCanary</a>，<a href="https://github。com/brianPlummer/TinyDancer" target="_blank" rel="external">TinyDancer</a>，模拟/改变应用的一些行为等等。</p>
<p>在运行中不需要修改代码来改变和检查应用的能力会节省你和QA团队成吨的时间。</p>
<p>尽早失败：像 LeakCanary 的工具会帮助你在你的分析系统中从真实用户接收到崩溃报告之前探测问题，在每次发布之前教你的QA团队使用这种工具作为可接受测试的一部分。</p>
<blockquote>
<p>请考虑你的开发文化，和你的团队成员讨论这个主题，你的开发过程和你build产品的质量会有显著的提高!</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dagger2依赖注入]]></title>
      <url>http://www.yangqinfeng.com/2016/01/25/2016-1-16-Dagger2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>许多android应用实例化对象经常要求其他依赖，举个例子，实例化twitter API client使用网络（retrofit），为了使用这个库，你也许需要加入解析库（Gson），另外，实现认证或缓存也许需要shared preference 或其他普通存储的类要求首先实例化它们并形成依赖链。</p>
<p>dagger2 为你分析这些依赖并生成代码把它们串起来。尽管有其他依赖注入库，大多受限于依赖XML，要求在运行时验证依赖问题或在启动时造成性能负担。dagger 2 完全通过使用java annotation processors和编译时检查来分析和验证依赖。直到现在它被认为是最高效的依赖注入框架之一。</p>
<a id="more"></a>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p><strong>简化获取共享实例</strong> 就像butterknife库使定义view，事件处理，资源的引用更简单，dagger 2 提供一种获取共享实例的简单方法。例如，一旦我们在Dagger中声明你的单个实例（MyTwtterApiClient 或 SharePreferences），我们可以用@inject注释域声明：</p>
<pre><code>public class MainActivity extends Activity {
   @Inject MyTwitterApiClient mTwitterApiClient;
   @Inject SharedPreferences sharedPreferences;

   public void onCreate(Bundle savedInstance) {
       // assign singleton instances to fields
       InjectorClass.inject(this);

   }      
</code></pre></li>
<li><strong>对于复杂依赖配置简单</strong>我们创建对象时都有潜在的顺序。dagger 2 遍历依赖图并生成容易理解和追踪的代码，通过获取引用并作为依赖传递给其他对象不但把你从手写你需要的大量模版代码中解救出来，也有助于简化重构，从此你可以致力于如何构建模型而不是关注创建它们的顺序。</li>
<li>使单元测试和集成测试更简单，因为依赖图由我们创建，我们可以容易的替换网络返回模型和模拟它的行为。</li>
<li><strong>域内实例</strong>你不仅能更方便管理在整个应用生命周期持续的实例，你也能凭借dagger 2 的优势去定义拥有更短生命周期的实例。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>添加依赖到<code>app/build.gradle</code>文件</p>
<pre><code>dependencies { 
    compile &apos;com.google.dagger:dagger:2.0&apos; 
    provided &apos;com.google.dagger:dagger-compiler:2.0&apos; 
    provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; 
}
</code></pre><p>注意：provided 关键字引用的依赖只在编译时需要。dagger 编译器生成创建你源码中类的依赖图的代码，在编译时这些类会被加入IDE class path。</p>
<p>android studio默认不会认为大量生成dagger 2代码为合法类，但是加入android apt 插件会添加这些文件到IDE class path 并使它们可见。</p>
<p>在根目录的<code>build.gradle</code>添加：</p>
<pre><code>dependencies { 
    // other classpath definitions here 
    classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
 }
</code></pre><p>确定在<code>app/build.gradle</code>文件中应用插件：</p>
<pre><code>// add after applying plugin: &apos;com.android.application&apos; 
apply plugin:&apos;com.neenbedankt.android-apt&apos;
</code></pre><h2 id="单个实例"><a href="#单个实例" class="headerlink" title="单个实例"></a>单个实例</h2><p><img src="https://raw.githubusercontent.com/codepath/android_guides/master/images/dagger_general.png" alt="image"><br>下面最简单的例子是教你如何通过dagger集中你所有的单例创建。假设你不会用任何类型的依赖注入框架并写下twitter client 和下面一样：</p>
<pre><code>OkHttpClient client = new OkHttpClient();

// Enable caching for OkHttp
int cacheSize = 10 * 1024 * 1024; // 10 MiB
Cache cache = new Cache(getApplication().getCacheDir(), cacheSize);
client.setCache(cache);

// Used for caching authentication tokens
SharedPreferences sharedPrefeences = PreferenceManager.getDefaultSharedPreferences(this);

// Instantiate Gson
Gson gson = new GsonBuilder().create();
GsonConverterFactory converterFactory = GsonConverterFactory.create(Gson);

// Build Retrofit
Retrofit retrofit = new Retrofit.Builder()
                                .baseUrl(&quot;https://api.github.com&quot;)
                                .addConverterFactory(converterFactory)
                                .client(client)  // custom client
                                .build();
</code></pre><h3 id="声明你的单个实例"><a href="#声明你的单个实例" class="headerlink" title="声明你的单个实例"></a>声明你的单个实例</h3><p>Declare your singletons</p>
<p>你需要通过创建dagger 2 module定义哪些对象应该作为依赖链中的部分被包含。比如，你希望创建一个绑定应用生命周期并且我们所有的activities的fragment都可以使用的retrofit单实例，我们首先要让dagger知道retrofit实例可以被提供。</p>
<p>因为我们希望初始化缓存，我们需要一个application context，我们第一的dagger module，AppModule，会用于提供这个引用。</p>
<pre><code>@Module
public class AppModule {

    Application mApplication;

    public AppModule(Application application) {
        mApplication = application;
    }

    @Provides
    @Singleton
    Application providesApplication() {
        return mApplication;
    }
}
</code></pre><p>我们创建一个NetModule类并用@Module注释来告诉dagger搜索实例提供者的可用方法。</p>
<p>这些实际上暴露可用的返回值类型的方法应该也被@provider修饰符注释，singleton 注释也告诉dagger编译器实例在应用中只应该创建一次。在下面了例子中，我们使用SharedPreferences ,  Gson ,  Cache ,  OkHttpClient  和  Retrofit 作为返回值类型可用作为依赖表的部分使用。</p>
<pre><code>@Module
public class NetModule {

    String mBaseUrl;

    // Constructor needs one parameter to instantiate. 
    public NetModule(String baseUrl) {
        this.mBaseUrl = baseUrl;
    }

    // Dagger will only look for methods annotated with @Provides
    @Provides
    @Singleton
    // Application reference must come from AppModule.class
    SharedPreferences providesSharedPreferences(Application application) {
        return PreferenceManager.getDefaultSharedPreferences(application);
    }

    @Provides
    @Singleton
    Cache provideOkHttpCache(Application application) {
        int cacheSize = 10 * 1024 * 1024; // 10 MiB
        Cache cache = new Cache(application.getCacheDir(), cacheSize);
        return cache;
    }

  @Provides
  @Singleton
  Gson provideGson() { 
      GsonBuilder gsonBuilder = new GsonBuilder();
      gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);
      return gsonBuilder.create();
  }

  @Provides
  @Singleton
  OkHttpClient provideOkHttpClient(Cache cache) {
      OkHttpClient client = new OkHttpClient();
      client.setCache(cache);
      return client;
  }

  @Provides
  @Singleton
  Retrofit provideRetrofit(Gson gson, OkHttpClient okHttpClient) {
      Retrofit retrofit = new Retrofit.Builder()
                .addConverterFactory(GsonConverterFactory.create(gson))
                .baseUrl(mBaseUrl)
                .client(okHttpClient)
                .build();
        return retrofit;
    }
}
</code></pre><p>注意方法名无关紧要它们可以命名成任何名字。被@provider修饰符注释的返回值类型用于连接这个实例和任何其他同样类型的模型。@sigleton注释用于告诉dagger只会被初始化一次在应用的整个生命周期。</p>
<p>retrofit实例依赖son和okhttpclient实例，因此我们可以在这个类中定义接受这两种类型的参数的方法，方法中@provider注释和这两个参数会使dagger 构建retrofit实例依赖son和okhhtpclient。</p>
<h3 id="定义注入目标"><a href="#定义注入目标" class="headerlink" title="定义注入目标"></a>定义注入目标</h3><p>Define injection targets</p>
<p>dagger 提供一种方法，在 activities, fragments, or services 的被赋值引用的域中注释@inject 并调用inject（）方法。调用inject（）会使dagger 2 在依赖图定位一个匹配返回值类型的实例。如果找到一个，他就会被赋值给对应的域。比如，在下面实例中，dagger会试图寻找返回MyTwitterApiClient 和 SharedPreferences类型的provider。</p>
<pre><code>public class MainActivity extends Activity {
  @Inject MyTwitterApiClient mTwitterApiClient;
  @Inject SharedPreferences sharedPreferences;

  public void onCreate(Bundle savedInstance) {
      // assign singleton instances to fields
      InjectorClass.inject(this);
  }
}
</code></pre><p>dagger 2 中使用的注入器 class 叫 component，为了定义一个实例之前访问它，componet会在我们的 activities, services, or fragments赋值其引用，我们需要在component class注释@component声明 ，注意activities, services, or fragments在component应该被独立的方法中声明</p>
<pre><code>@Singleton
@Component(modules={AppModule.class, NetModule.class})
public interface NetComponent {
  void inject(MainActivity activity);
  // void inject(MyFragment fragment);
  // void inject(MyService service);
}
</code></pre><p>注意基类作为注入目标是不充分的。dagger 2依赖强类型的类，所以你必须显示指出注入目标类(There are suggestions to workaround the issue, but the code to do so may be more complicated to trace than simply defining them.)。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>dagger 2 重要的一面是library生成被@component注释的类的代码，你可以使用以Dagger_开头的类，它会响应实例化我们依赖图中的一个实例并使用它对注释@inject的域执行注入。检查 setup guide并确信你已经加入android apt 插件，它会允许你更好的理解dagger2生成的类。</p>
<h3 id="实例化component"><a href="#实例化component" class="headerlink" title="实例化component"></a>实例化component</h3><p>我们应该在Application类中执行这个工作，因为这些实例应该在应用的整个生命周期中声明一次：</p>
<pre><code>public class MyApp extends Application {

    private NetComponent mNetComponent;

    @Override
    public void onCreate() {
        super.onCreate();

        // specify the full namespace of the component
        // Dagger_xxxx (where xxxx = component name)
        mNetComponent = com.codepath.dagger.components.DaggerNetComponent.builder()
                // list of modules that are part of this component need to be created here too
                .appModule(new AppModule(this))
                .netModule(new NetModule(&quot;https://api.github.com&quot;))
                .build();

        // If a Dagger 2 component does not have any constructor arguments for any of its modules,
        // then we can use .create() as a shortcut instead:
        //  mAppComponent = com.codepath.dagger.components.DaggerNetComponent.create();
    }

    public NetComponent getNetComponent() {
      return mNetComponent;
    }
}
</code></pre><p>因为我们覆盖了默认的Application类，我们也要修改启动应用的application name，这种方法你的应用会使用你的application 类来初始化实例。</p>
<pre><code>&lt;application
      android:allowBackup=&quot;true&quot;
      android:name=&quot;.MyApp&quot;&gt;
</code></pre><p>在我们的activity中，我们需要简单的获取这些component并调用inject（）</p>
<pre><code>public class MyActivity extends Activity {
  @Inject OkHttpClient mOkHttpClient;
  @Inject SharedPreferences sharedPreferences;

  public void onCreate(Bundle savedInstance) {
        // assign singleton instances to fields
        // We need to cast to `MyApp` in order to get the right method
        ((MyApp) getApplication()).getNetComponent()).inject(this);
    }
}
</code></pre><h3 id="限定类型"><a href="#限定类型" class="headerlink" title="限定类型"></a>限定类型</h3><p>Qualified types<br><img src="https://raw.githubusercontent.com/codepath/android_guides/master/images/dagger_qualifiers.png" alt="Dagger Qualifiers"><br>如果我们需要两个不同的对象但返回值类型相同，我们可以使用@name 限定符注释。你应该定义它们在我们提供实例( @Provides  annotation)和注入它们 ( @Inject  annotations）的地方。</p>
<pre><code>@Provides @Named(&quot;cached&quot;)
@Singleton
OkHttpClient provideOkHttpClient(Cache cache) {
    OkHttpClient client = new OkHttpClient();
    client.setCache(cache);
}

@Provides @Named(&quot;non_cached&quot;) @Singleton
OkHttpClient provideOkHttpClient() {
    OkHttpClient client = new OkHttpClient();
    return client;
}
</code></pre><p>注入也会要求注释</p>
<pre><code>@Inject @Named(&quot;cached&quot;) OkHttpClient client;
@Inject @Named(&quot;non_cached&quot;) OkHttpClient client2;
</code></pre><p>@name 由dagger预定义的限定符，你也可以创建你自己的限定符注释</p>
<pre><code>@Qualifier
@Documented
@Retention(RUNTIME)
public @interface DefaultPreferences {
}
</code></pre><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>Scopes<br><img src="https://raw.githubusercontent.com/codepath/android_guides/master/images/dagger_scopes.png" alt="Dagger Scopes"><br>域（Scope） 注释使dagger持有给定component提供对象的单个实例，没有域的提供者方法在任何给定类型被注入的时间都会被调用创建一个新对象</p>
<p>@singleton 是 由dagger定义的域（Scope）注释，你也可以在你的应用中定义无数域（Scope）注释</p>
<pre><code>@Scope
@Documented
@Retention(value=RUNTIME)
public @interface MyActivityScope
</code></pre><h3 id="Component依赖"><a href="#Component依赖" class="headerlink" title="Component依赖"></a>Component依赖</h3><p>Component Dependencies<br><img src="https://raw.githubusercontent.com/codepath/android_guides/master/images/dagger_dependency.png" alt="Dagger Component Dependencies"><br>上面例子展示了我们使用持续应用整个生命周期的单实例。我们也依赖一个主要dagger componet。如果我们希望有多个不需要一直存在于内存的component （绑定 activity 或 fragment，甚至绑定用户登录状态 ），我们能创建依赖组件，当我们使用依赖组件有下面几点考虑</p>
<ul>
<li>两个依赖组件不能分享相同域（scope）比如，两个不同的组件不能同时被@singleton注释，这个规定被强行执行因为 here。依赖组件需要定义自己的域</li>
<li>尽管dagger 2 有创建域实例的能力，但是其责任需要你创建和删除引用与目标行为一致。dagger 2并不知道关于下层的任何实现。</li>
<li><p>当创建依赖组件时，父组件需要显示暴露对象给下游对象，比如，如果下游组件需要获取retrofit实例，component需要显式通过对应的返回值类型暴露它</p>
<pre><code>@Singleton
@Component(modules={AppModule.class, NetModule.class})
public interface NetComponent {
    // downstream components need these exposed with the return type
    // method name does not really matter
    Retrofit retrofit();
}
</code></pre></li>
</ul>
<p>比如，如果我们在应用内部使用依赖组件创建用于用户登录链接生命周期，我们可以定义自己的UserScope 接口</p>
<pre><code>import java.lang.annotation.Retention;
import javax.inject.Scope;

@Scope
public @interface UserScope {
}
</code></pre><p>我们可以作为子组件</p>
<pre><code>@UserScope // using the previously defined scope, note that @Singleton will not work
@Component(dependencies = NetComponent.class, modules = GitHubModule.class)
public interface GitHubComponent {
    void inject(MainActivity activity);
}
</code></pre><p>假设 这个github module 简单返回一个github api接口</p>
<pre><code>@Module
public class GitHubModule {

    public interface GitHubApiInterface {
      @GET(&quot;/org/{orgName}/repos&quot;)
      Call&lt;ArrayList&lt;Repository&gt;&gt; getRepository(@Path(&quot;orgName&quot;) String orgName);
    }

    @Provides
    @UserScope // needs to be consistent with the component scope
    public GitHubApiInterface providesGitHubInterface(Retrofit retrofit) {
        return retrofit.create(GitHubApiInterface.class);
    }
}
</code></pre><p>为了GithubModule 获取retrofit实例，我们需要在上游组件显式定义它，如果下游将要执行注入，它们也应该从上游组件移除</p>
<pre><code>@Singleton
@Component(modules={AppModule.class, NetModule.class})
public interface NetComponent {
    // remove injection methods if downstream modules will perform injection

    // downstream components need these exposed
    Retrofit retrofit();
    OkHttpClient okHttpClient();
    SharedPreferences sharedPreferences();
}
</code></pre><p>最后一步使用实例化GitHubComponent，此时，我们首先需要构建NetComponent并传人DaggerGitHubComponent的构造器中。</p>
<pre><code>NetComponent netComponent = DaggerNetComponent.builder()
                .appModule(new AppModule(this))
                .netModule(new NetModule(&quot;https://api.github.com&quot;))
                .build();

GitHubComponent gitHubComponent = DaggerGitHubComponent.builder()
                .netComponent(mNetComponent)
                .gitHubModule(new GitHubModule())
                .build();
</code></pre><h2 id="Subcomponents"><a href="#Subcomponents" class="headerlink" title="Subcomponents"></a>Subcomponents</h2><p><img src="https://raw.githubusercontent.com/codepath/android_guides/master/images/dagger_subcomponent.png" alt="Dagger subcomponents"><br>使用 Subcomponent 是另一种扩展一个组件的对象图，有依赖，subcomponent的组件有它们自己的生命周期当所有subcomponent的引用消失时可以被gc</p>
<p>依赖subcomponent主要不同</p>
<ul>
<li><p>需要在父接口被声明</p>
</li>
<li><p>可以获取父组件图的所有元素</p>
</li>
</ul>
<p>对activity使用subcomponent的例子</p>
<pre><code>@Module
public class MyActivityModule {
    private final MyActivity activity;
    public MyActivityModule(MyActivity activity) { this.activity = activity; }

    @Provides @MyActivityScope @Named(&quot;my_list&quot;)
    public ArrayAdapter providesMyListAdapter() {
        return new ArrayAdapter&lt;String&gt;(activity, android.R.layout.my_list);
    }
    ...
}


@MyActivityScope
@Subcomponent(modules={ MyActivityModule.class })
public interface MyActivitySubComponent {
    @Named(&quot;my_list&quot;) ArrayAdapter myListAdapter();
}

@Singleton
@Component(modules={ ... })
public interface MyApplicationComponent {
    MyActivitySubComponent newMyActivitySubcomponent(MyActivityModule activityModule);
}
</code></pre><p>在上面例子中，每次调用newMyActivitySubcomponent（）时都会创建一个subcomponent的新实例，使用subcomponent注入到activity 中</p>
<pre><code>public class MyActivity extends Activity {
  @Inject ArrayAdapter arrayAdapter;

  public void onCreate(Bundle savedInstance) {
        // assign singleton instances to fields
        // We need to cast to `MyApp` in order to get the right method
        ((MyApp) getApplication()).getApplicationComponent())
            .newMyActivitySubcomponent(new MyActivityModule(this))
            .inject(this);
    }
}
</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2#" target="_blank" rel="external">原文链接</a></p>
<ul>
<li><a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2 Github Page</a></li>
<li><a href="https://github.com/vinc3m1/nowdothis" target="_blank" rel="external">Sample project using Dagger 2</a></li>
<li><a href="https://docs.google.com/presentation/d/1bkctcKjbLlpiI0Nj9v0QpCcNIiZBhVsJsJp1dgU5n98/" target="_blank" rel="external">Vince Mi’s Codepath Meetup Dagger 2 Slides</a></li>
<li><a href="http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345" target="_blank" rel="external">http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345</a></li>
<li><a href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014" target="_blank" rel="external">Jake Wharton’s Devoxx Dagger 2 Slides</a></li>
<li><a href="https://www.parleys.com/tutorial/5471cdd1e4b065ebcfa1d557/" target="_blank" rel="external">Jake Wharton’s Devoxx Dagger 2 Talk</a></li>
<li><a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">Dagger 2 Google Developers Talk</a></li>
<li><a href="http://frogermcs.github.io/dagger-1-to-2-migration/" target="_blank" rel="external">Dagger 1 to Dagger 2</a></li>
<li><a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="external">Tasting Dagger 2 on Android</a></li>
<li><a href="http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html#sthash.IMzjLiVu.dpuf" target="_blank" rel="external">Dagger 2 Testing with Mockito</a></li>
<li><a href="https://github.com/konmik/konmik.github.io/wiki/Snorkeling-with-Dagger-2" target="_blank" rel="external">Snorkeling with Dagger 2</a> </li>
<li><a href="https://www.objc.io/issues/11-android/dependency-injection-in-java/" target="_blank" rel="external">Dependency Injection in Java</a></li>
<li><a href="http://jellybeanssir.blogspot.de/2015/05/component-dependency-vs-submodules-in.html" target="_blank" rel="external">Component Dependency vs. Submodules in Dagger 2</a></li>
<li><a href="https://github.com/joesteele/dagger2-component-scopes-test" target="_blank" rel="external">Dagger 2 Component Scopes Test</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android库项目的依赖管理]]></title>
      <url>http://www.yangqinfeng.com/2016/01/13/2016-01-13-Android%E5%BA%93%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>当android开发者针对他们的项目选择library时，他们不仅仅关注功能，易用性，性能，文档，技术支持。他们也很关心library的size和增加项目方法的数量，随着项目的增长，它的依赖也一样（在增长），开发者对保持他的App的方法数在65k限制以下感到压力。等待non-release builds的Proguard（混淆器）太慢,开发者试图避免瘟疫一样multidex。这就是为什么library作者认为他们的项目的大小很重要。</p>
<a id="more"></a>
<p>控制你的library的方法数最简单的方法是不加入任何非必需的依赖。任何library加入的依赖会传递性的加入用户的项目中。例如，如果你需要几个简单的工具方法（像关闭资源），不要为它去加入Guava依赖，自己写或从通过现有library解决。当你自需要几个工具方法并没有加入14k方法，你的用户肯定会感激你。</p>
<p>那并不是说你应该经常避免使用外部libraries。你只需要稍加考虑，有http libraries时不要写一个http client，你应该停止浪费时间去更好的改善你的library。</p>
<p>不考虑加入依赖的简单方法，你可以使用下面几种方法保持你library的“身材”，一种方法是声明依赖时使用 provide scope ，它属于android gradle 构建系统的一部分。对立的是compile，provide scope只会在编译时加入依赖 ，这意味着当用户们build他们的项目时依赖不会被打包到APK中。使用依赖的用户需要在他们的应用显式声明依赖。</p>
<p>注释：也可以选择package scope，依赖会被打包到APK但编译时不可用。</p>
<p>在你的library项目中使用可选依赖的原因：</p>
<p>1.依赖的核心功能只会被你用户的子集用到，在Retrofit 1.x就可以看到，用户可以通过响应式的调用REST calls而不是回调，那些想使用RxJava的用户可以加入其依赖，其他用户不用负担额外依赖。 Retrofit 使用maven构建系统后配置稍有不同，但是思路是一致的。</p>
<p>我应该警告你发现你自己加入的依赖的功能不是对所有用户都有用，你真的应该考虑依赖的功能是否应该作为你library的一部分，稍后再详细说明。</p>
<p>2.android框架中已经存在一种解决方案，但是外部library提供一种更高效解决方案。为了更好的性能已加入外部依赖或愿意承担增长的方法数的用户可以加入依赖。</p>
<p>最近我无意中在PlacesAutocompleteTextView library发现这种方法的应用，它内部的http client可以是okhttp client或是http url connection，前者总体来说性能更高，但是要求添加okhttp依赖。如果用户不希望添加它，他会自动回退使用标准库的http url connection。</p>
<p>为应用此方法，由resolver（决策者）这个类在运行时决定依赖那个library。例如下面这个类来决定使用哪个http client</p>
<pre><code>public final class PlacesHttpClientResolver { 
    public static final PlacesHttpClient PLACES_HTTP_CLIENT; 
    static { 
        boolean hasOkHttp; 
        try { 
            Class.forName(&quot;com.squareup.okhttp.OkHttpClient&quot;);
            hasOkHttp = true; 
        } catch (ClassNotFoundException e) { 
            hasOkHttp = false; 
        } 
        PlacesApiJsonParser parser = JsonParserResolver.JSON_PARSER;
        PLACES_HTTP_CLIENT = hasOkHttp ? new OkHttpPlacesHttpClient(parser) : new HttpUrlConnectionMapsHttpClient(parser); 
        } 
    private PlacesHttpClientResolver() { throw new RuntimeException(&quot;No Instances!&quot;); } 
}
</code></pre><p>当类被加载，通过全路径类名检查okhttpclient的可用性，如果抛出classnotfoundexception，然后我就知道okhttp没有被用户添加，我们回退到httpurlconnection。placeshttpclient作为包装类了通过内部代码库使用所有实现中一种的接口。同样的方法可以被用到json解析，gson可以作为可选依赖。</p>
<p>如果平衡性能和大小很重要，这种方法是不错的。一般回退的实现需要更多的精力（例如json parsing）我推荐一开始使用外部library节省时间然后考虑在后续发布版本加入回退实现。</p>
<p>我先前提到你应该考虑你的library 包含哪个功能。如果某个功能不会被几乎所有用户所使用，最好还是不要引入它。这令第一种使用可选依赖的方法更少被采纳。再以retrofit为例，它在2.x发布版本不再提供消费响应式rest calls 作为它核心库的一部分。这一功能被移动到分离模块作为他所在的maven特性发布。</p>
<p>同样的，不同response转换器也被分到它们自己的依赖，例如，需要转换json response 和已经依赖gson的retofit 用户可以添加下面依赖到他们的build.gradle 文件</p>
<pre><code>dependencies {
      compile &apos;com.squareup.retrofit:converter-gson:2.0.0-beta2&apos;
}
</code></pre><p>使用不同json库像jackson或需要解析不同数据格式像xml或protobuf buffers的用户可以这样做而不必负担所有服务retrofit用户的外部库。重要的一点，核心库不会被多余的功能污染，聚焦的主要观点被解决。</p>
<p>如果你发现android开发者会使用你自己写的库，当你设计时用上这些策略。考虑你库的大小不仅仅作为附属，而是一种特性。为此你的用户会由衷的感谢你。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://johnpetitto.com/android-lib-dependency-management/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
  
  
</search>
